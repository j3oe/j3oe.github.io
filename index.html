<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Perceptual Empathy</title>
  <meta name="description" content="Perceptual Empathy — an interactive art piece exploring how perception shifts when sights and sounds compete for attention.">
  <style>
    :root{
      --bg:#070914; --card:#0e1420; --accent:#7dd3fc; --muted:#94a3b8;
    }
    html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;color:#e6eef6;background:radial-gradient(1200px 600px at 10% 10%, #071022 0%, #04060a 40%);}
    header{padding:18px 22px;display:flex;align-items:center;justify-content:space-between;gap:12px}
    h1{font-size:1.05rem;margin:0}
    .controls{display:flex;gap:8px;align-items:center}
    button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--accent);padding:8px 12px;border-radius:10px;cursor:pointer}
    button.ghost{border-style:dashed;color:var(--muted)}
    .container{display:grid;grid-template-columns:1fr 360px;gap:18px;padding:12px}
    main{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:12px;min-height:68vh;position:relative;overflow:hidden}
    canvas.layer{position:absolute;left:0;top:0;width:100%;height:100%;}
    #uiPanel{position:relative;z-index:60}
    aside{background:rgba(255,255,255,0.02);border-radius:12px;padding:16px;color:var(--muted)}
    aside h2{color:var(--accent);margin-top:0}
    label{display:block;font-size:0.9rem;margin-bottom:8px}
    input[type=range]{width:100%}
    .credits{font-size:0.82rem;margin-top:14px}
    .warning{background:#3a0b0b;padding:10px;border-radius:8px;color:#ffd7d7;margin-bottom:12px}
    footer{font-size:0.8rem;color:var(--muted);padding:12px 20px}
    .badge{font-size:0.75rem;padding:6px 8px;border-radius:8px;background:rgba(125,211,252,0.06);color:var(--accent)}
    .corner-glow{position:absolute;right:-120px;top:-120px;width:420px;height:420px;border-radius:50%;filter:blur(90px);opacity:0.06;background:linear-gradient(90deg,#7dd3fc55,#f0abfc55)}
    .small{font-size:0.78rem;color:var(--muted)}
    .row{display:flex;gap:8px;align-items:center}
    select{background:transparent;border:1px solid rgba(255,255,255,0.04);padding:6px;border-radius:8px;color:var(--muted)}
  </style>
</head>
<body>
  <header>
    <div style="display:flex;gap:12px;align-items:center">
      <div class="badge">Perceptual Empathy</div>
      <h1>Perceptual Empathy — advanced demo</h1>
    </div>
    <div class="controls">
      <button id="startBtn">Start</button>
      <button id="pauseBtn" aria-pressed="false">Pause</button>
      <button id="stopBtn" class="ghost">Stop & Reset</button>
      <button id="helpBtn" class="ghost">About</button>
    </div>
  </header>

  <div class="container">
    <main aria-live="polite">
      <div class="corner-glow" aria-hidden="true"></div>

      <!-- layered canvases for parallax / feedback -->
      <canvas class="layer" id="bgLayer" width="1200" height="800" aria-hidden="true"></canvas>
      <canvas class="layer" id="midLayer" width="1200" height="800" aria-hidden="true"></canvas>
      <canvas class="layer" id="fgLayer" width="1200" height="800" role="img" aria-label="Dynamic visualization representing shifting perception"></canvas>

      <div style="position:absolute;left:18px;bottom:18px;background:rgba(2,6,11,0.5);padding:8px;border-radius:8px;color:var(--muted);font-size:0.9rem">Intensity: <span id="intDisplay">0.50</span></div>
    </main>

    <aside id="uiPanel">
      <h2>Control panel</h2>
      <p class="warning"><strong>Trigger warning:</strong> Some visuals and sounds may be unsettling. Pause or Stop if you feel uncomfortable.</p>

      <label for="intensity">Intensity</label>
      <input id="intensity" type="range" min="0" max="1" step="0.01" value="0.5" aria-label="Intensity slider">

      <label for="complexity">Visual complexity</label>
      <input id="complexity" type="range" min="1" max="10" step="1" value="3">

      <div style="margin-top:12px" class="row">
        <label for="soundToggle"><input id="soundToggle" type="checkbox" checked> Enable sound</label>
        <select id="preset" title="Select a preset">
          <option value="chaos">Chaos</option>
          <option value="spiral">Spiral</option>
          <option value="pulse">Pulse</option>
          <option value="grain">Grainstorm</option>
        </select>
      </div>

      <div class="credits">
        <strong>Purpose</strong>
        <p class="small">This experiment shows how competing sounds and sights can make focus harder. Educational only not clinical or diagnostic.</p>
      </div>

      <div style="margin-top:12px">
        <a href="#resources" id="resourcesLink" style="color:var(--accent);text-decoration:none">Resources & Support</a>
      </div>

      <div style="margin-top:18px;font-size:0.85rem;color:var(--muted)">
        <strong>Controls</strong>
        <ul>
          <li>Start / Pause / Stop</li>
          <li>Intensity: increases rotation speed, strobe rate, and audio detune</li>
          <li>Complexity: adds more layered motion and chromatic shifts</li>
          <li>Esc: quick exit (stops audio & hides visuals)</li>
        </ul>
      </div>
    </aside>
  </div>

  <footer>
    <div id="readme">
      <strong>Readme</strong>
      <p>An interactive art piece to help visitors explore how perception can shift when thoughts, sounds, and sights compete for attention. It's an educational experiment, not a clinical tool.</p>
      <p><em>Important:</em> Trigger warning: Some people may find the visuals or sounds unsettling. Not medical advice. If you feel distressed, pause the demo and visit <a href="https://findahelpline.com" target="_blank" rel="noopener">findahelpline.com</a> or a local support service.</p>
    </div>
  </footer>

  <div id="resources" style="display:none">
    <h3>Resources</h3>
    <p><a href="https://findahelpline.com" target="_blank" rel="noopener">findahelpline.com</a></p>
  </div>

  <script>
    // ============= FIXED & IMPROVED Single-file demo ==============
    // Fixes applied in this revision:
    //  - Removed malformed string literal that contained an unescaped newline (caused the 'Invalid or unexpected token' SyntaxError).
    //  - Made noiseGain globally available so updateAudio can control it safely.
    //  - Prevent drawing a canvas into itself by copying FG into an offscreen canvas before applying chromatic shifts.
    //  - Added defensive resizing for offscreen canvases and robust checks to avoid operations on zero-sized canvases.
    //  - Added a few lightweight runtime tests (console.assert) to help detect common environment/setup issues.

    // --- Elements ---
    const bg = document.getElementById('bgLayer');
    const mid = document.getElementById('midLayer');
    const fg = document.getElementById('fgLayer');
    const canvases = [bg, mid, fg];
    const cctx = canvases.map(c => c.getContext('2d'));
    const intensityEl = document.getElementById('intensity');
    const complexityEl = document.getElementById('complexity');
    const intDisplay = document.getElementById('intDisplay');
    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const stopBtn = document.getElementById('stopBtn');
    const helpBtn = document.getElementById('helpBtn');
    const soundToggle = document.getElementById('soundToggle');
    const preset = document.getElementById('preset');

    // Offscreen canvases: feedback buffer and fg copy
    const fbCanvas = document.createElement('canvas');
    const fbCtx = fbCanvas.getContext('2d');
    const copyCanvas = document.createElement('canvas');
    const copyCtx = copyCanvas.getContext('2d');

    // sizing
    function updateFBSize(){
      const ratio = Math.max(1, window.devicePixelRatio || 1);
      try{
        fbCanvas.width = Math.max(1, Math.floor(mid.clientWidth * ratio));
        fbCanvas.height = Math.max(1, Math.floor(mid.clientHeight * ratio));
        copyCanvas.width = Math.max(1, Math.floor(fg.clientWidth * ratio));
        copyCanvas.height = Math.max(1, Math.floor(fg.clientHeight * ratio));
      }catch(e){
        // If layout isn't ready, fall back to viewport size
        const w = Math.max(1, Math.floor(window.innerWidth * ratio));
        const h = Math.max(1, Math.floor((window.innerHeight * 0.7) * ratio));
        fbCanvas.width = copyCanvas.width = w;
        fbCanvas.height = copyCanvas.height = h;
      }
    }

    function resize(){
      const ratio = Math.max(1, window.devicePixelRatio || 1);
      for(const c of canvases){
        try{
          c.width = Math.max(1, Math.floor(c.clientWidth * ratio));
          c.height = Math.max(1, Math.floor(c.clientHeight * ratio));
        }catch(e){
          c.width = Math.max(1, Math.floor(window.innerWidth * ratio));
          c.height = Math.max(1, Math.floor((window.innerHeight * 0.7) * ratio));
        }
      }
      updateFBSize();
    }
    window.addEventListener('resize', resize);
    resize();

    // state
    let running = false;
    let last = 0;
    let startTime = performance.now();

    // visual layers data
    const layers = [];
    function initLayers(){
      layers.length = 0;
      const count = Math.max(1, parseInt(complexityEl.value,10) || 3);
      for(let i=0;i<count;i++){
        layers.push({
          angle: Math.random()*Math.PI*2,
          speed: 0.0005 + Math.random()*0.0015,
          radius: 40 + i*30,
          hue: Math.random()*360,
          offset: Math.random()*1000
        });
      }
    }
    initLayers();

    // audio engine
    let audioCtx = null;
    let masterGain = null;
    let oscNodes = [];
    let noiseNode = null;
    let noiseGain = null; // made global so updateAudio can adjust
    let panner = null;

    function initAudio(){
      if(audioCtx) return;
      try{
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = audioCtx.createGain(); masterGain.gain.value = 0; masterGain.connect(audioCtx.destination);

        // layered oscillators
        const freqs = [110, 165, 220, 330];
        for(const f of freqs){
          const o = audioCtx.createOscillator(); o.type = 'sine'; o.frequency.value = f;
          const g = audioCtx.createGain(); g.gain.value = 0;
          o.connect(g); g.connect(masterGain); o.start();
          oscNodes.push({osc:o,gain:g});
        }

        // noise
        const buf = audioCtx.createBuffer(1, audioCtx.sampleRate*2, audioCtx.sampleRate);
        const dat = buf.getChannelData(0);
        for(let i=0;i<dat.length;i++) dat[i] = (Math.random()*2-1)*0.6;
        noiseNode = audioCtx.createBufferSource(); noiseNode.buffer = buf; noiseNode.loop = true;
        noiseGain = audioCtx.createGain(); noiseGain.gain.value = 0; noiseNode.connect(noiseGain); noiseGain.connect(masterGain); noiseNode.start();

        // panner
        panner = audioCtx.createStereoPanner(); masterGain.connect(panner); panner.connect(audioCtx.destination);

      }catch(e){ console.warn('Audio init failed', e); }
    }

    function updateAudio(){
      if(!audioCtx) return;
      const intensity = parseFloat(intensityEl.value);
      const complexity = parseInt(complexityEl.value,10);
      const vol = 0.02 + intensity*0.25;
      masterGain.gain.linearRampToValueAtTime(vol, audioCtx.currentTime + 0.08);

      oscNodes.forEach((o,i)=>{
        const g = 0.01 + intensity*(0.02 + i*0.01);
        o.gain.gain.linearRampToValueAtTime(g, audioCtx.currentTime + 0.08);
        // detune with slow LFO and intensity
        const det = Math.sin((Date.now()/1000) * (0.15 + i*0.05)) * (10 + i*5) * intensity;
        o.osc.detune.setTargetAtTime(det, audioCtx.currentTime, 0.3);
      });

      // noise amplitude tied to complexity (use noiseGain if available)
      if(noiseGain){
        const ng = Math.min(1.0, (complexity/6) * (0.2 + intensity*0.8));
        noiseGain.gain.linearRampToValueAtTime(ng, audioCtx.currentTime + 0.08);
      }

      // panner wobble
      if(panner) panner.pan.setValueAtTime(Math.sin(Date.now()/2000) * intensity, audioCtx.currentTime);

      // occasional glitch grains
      if(Math.random() < intensity*0.02 + complexity*0.01){ grainBurst(intensity); }
    }

    function grainBurst(intensity){
      if(!audioCtx) return;
      const size = 0.03 + Math.random()*0.15;
      const b = audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate * size), audioCtx.sampleRate);
      const d = b.getChannelData(0);
      for(let i=0;i<d.length;i++) d[i] = (Math.random()*2-1) * (0.9 * intensity);
      const src = audioCtx.createBufferSource(); src.buffer = b; const g = audioCtx.createGain(); g.gain.value = 0; src.connect(g); g.connect(masterGain); src.start(); g.gain.linearRampToValueAtTime(0.12*intensity, audioCtx.currentTime + 0.01); g.gain.linearRampToValueAtTime(0.0, audioCtx.currentTime + size);
    }

    // render loop — layered drawing with chromatic shifts and strobe
    function render(now){
      if(!running) return;
      const t = (now - startTime) / 1000;
      const intensity = parseFloat(intensityEl.value);
      const complexity = Math.max(1, parseInt(complexityEl.value,10));

      intDisplay.textContent = intensity.toFixed(2);

      // clear layers with subtle alpha to create smearing feedback
      cctx[0].fillStyle = `rgba(1,3,6,${0.03 + intensity*0.08})`; cctx[0].fillRect(0,0,bg.width,bg.height);
      cctx[1].fillStyle = `rgba(0,0,0,${0.05 + intensity*0.06})`; cctx[1].fillRect(0,0,mid.width,mid.height);
      cctx[2].clearRect(0,0,fg.width,fg.height);

      // draw background noise field
      for(let i=0;i<40 + complexity*20;i++){
        const x = (Math.sin(t*0.13 + i)*0.5+0.5) * bg.width;
        const y = (Math.cos(t*0.11 + i)*0.5+0.5) * bg.height;
        const r = 8 + ((i*7) % 60) * (0.5 + intensity*1.2);
        cctx[0].beginPath(); cctx[0].fillStyle = `hsla(${(i*13 + t*40) % 360},60%,60%,${0.02 + intensity*0.08})`; cctx[0].arc(x,y,r,0,Math.PI*2); cctx[0].fill();
      }

      // mid layer: rotating warped rings + feedback smear
      fbCtx.globalCompositeOperation = 'source-over';
      fbCtx.fillStyle = `rgba(0,0,0,${0.05 + intensity*0.06})`;
      fbCtx.fillRect(0,0,fbCanvas.width,fbCanvas.height);

      for(let j=0;j<complexity;j++){
        const a = t * (0.2 + j*0.12) * (1 + intensity*3.5);
        const cx = fbCanvas.width/2 + Math.sin(t*0.9 + j) * (60 + j*18) * intensity;
        const cy = fbCanvas.height/2 + Math.cos(t*0.7 + j) * (40 + j*12) * intensity;
        const rad = 60 + j*30 + Math.sin(t*0.6 + j) * 25 * intensity;
        fbCtx.beginPath(); fbCtx.lineWidth = 2 + intensity*6; fbCtx.strokeStyle = `hsla(${(j*40 + t*60) % 360},70%,55%,${0.06 + intensity*0.18})`;
        fbCtx.arc(cx, cy, rad, a, a + Math.PI*2); fbCtx.stroke();
      }

      // apply slight blur-ish composite to mid layer
      cctx[1].globalCompositeOperation = 'lighter';
      cctx[1].drawImage(fbCanvas, 0, 0, mid.width, mid.height);
      cctx[1].globalCompositeOperation = 'source-over';

      // foreground: spirals, chromatic offsets, strobe flash
      for(let l=0;l<3 + complexity;l++){
        const ang = t * (0.3 + l*0.25) * (1 + intensity*4) + l;
        const hue = (l*90 + t*80) % 360;
        const cx = fg.width/2;
        const cy = fg.height/2;
        cctx[2].save();
        cctx[2].translate(cx,cy);
        cctx[2].rotate(ang + Math.sin(t*0.9 + l)*0.2*intensity);
        cctx[2].beginPath();
        for(let s=0;s<120;s++){
          const r = 8 + s * (4 + intensity*6) * (1 + Math.sin(s*0.12 + t*1.2)*0.2);
          const a = s * 0.18;
          const x = Math.cos(a) * r; const y = Math.sin(a) * r;
          if(s===0) cctx[2].moveTo(x,y); else cctx[2].lineTo(x,y);
        }
        cctx[2].lineWidth = 1 + intensity*2;
        cctx[2].strokeStyle = `hsla(${hue},80%,55%,${0.08 + intensity*0.55})`;
        cctx[2].stroke();
        cctx[2].restore();
      }

      // chromatic fringe: copy current fg to offscreen and draw shifted translucent copies
      try{
        // copy full fg into copyCanvas
        copyCtx.clearRect(0,0,copyCanvas.width, copyCanvas.height);
        copyCtx.drawImage(fg, 0, 0, copyCanvas.width, copyCanvas.height);

        cctx[2].globalCompositeOperation = 'lighter';
        for(let shift=1; shift<=3; shift++){
          cctx[2].save();
          cctx[2].globalAlpha = 0.02 * intensity * (4-shift);
          cctx[2].filter = `blur(${0.4*shift}px)`;
          cctx[2].translate(Math.sin(shift + t*0.5)*3*intensity*shift, Math.cos(shift + t*0.7)*3*intensity*shift);
          cctx[2].drawImage(copyCanvas, 0, 0);
          cctx[2].restore();
        }
        cctx[2].globalCompositeOperation = 'source-over';
      }catch(e){
        // drawing copy may fail in some contexts — swallow to avoid fatal errors
        console.warn('Chromatic copy/draw skipped', e);
      }

      // small randomized noise / scanlines for additional discomfort
      cctx[2].globalCompositeOperation = 'overlay';
      for(let i=0;i<12;i++){
        const y = Math.random()*fg.height;
        cctx[2].fillStyle = `rgba(255,255,255,${0.002 + Math.random()*0.01 + intensity*0.01})`;
        cctx[2].fillRect(0,y,fg.width,1);
      }
      cctx[2].globalCompositeOperation = 'source-over';

      updateAudio();
      requestAnimationFrame(render);
    }

    // controls
    startBtn.addEventListener('click', async ()=>{
      if(!audioCtx && soundToggle.checked) initAudio();
      if(audioCtx && audioCtx.state === 'suspended') await audioCtx.resume();
      if(!running){ running = true; last = performance.now(); startTime = performance.now(); requestAnimationFrame(render); }
    });

    pauseBtn.addEventListener('click', ()=>{
      running = !running;
      if(!running){ pauseBtn.textContent = 'Resume'; if(audioCtx) audioCtx.suspend(); }
      else{ pauseBtn.textContent = 'Pause'; if(audioCtx) audioCtx.resume(); last = performance.now(); requestAnimationFrame(render); }
    });

    stopBtn.addEventListener('click', ()=>{
      running = false; pauseBtn.textContent = 'Resume'; intensityEl.value = 0; intDisplay.textContent = '0.00'; if(audioCtx) audioCtx.suspend();
      // clear canvases
      for(const ctx of cctx) ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height);
    });

    helpBtn.addEventListener('click', ()=>{
      // Use a template string for safe multiline content (avoids unescaped raw newlines that cause SyntaxError)
      alert(`Perceptual Empathy — Advanced

An educational interactive demo. Trigger warning: flashing visuals and unsettling sounds. Press ESC to stop.`);
    });

    intensityEl.addEventListener('input', ()=>{ intDisplay.textContent = parseFloat(intensityEl.value).toFixed(2); updateAudio(); });
    complexityEl.addEventListener('input', ()=>{ initLayers(); updateAudio(); });
    preset.addEventListener('change', ()=>{
      const p = preset.value;
      if(p === 'chaos'){ intensityEl.value = 0.85; complexityEl.value = 5; }
      else if(p === 'spiral'){ intensityEl.value = 0.45; complexityEl.value = 3; }
      else if(p === 'pulse'){ intensityEl.value = 0.6; complexityEl.value = 2; }
      else if(p === 'grain'){ intensityEl.value = 0.95; complexityEl.value = 6; }
      intDisplay.textContent = parseFloat(intensityEl.value).toFixed(2);
      initLayers(); updateAudio();
    });

    // ESC immediate exit
    window.addEventListener('keydown', (e)=>{
      if(e.key === 'Escape'){
        running = false; if(audioCtx) audioCtx.suspend(); for(const ctx of cctx) ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height); document.body.style.filter = 'grayscale(1)'; setTimeout(()=>{document.body.style.filter='';}, 400);
      }
    });

    // initialize
    initLayers(); updateFBSize(); resize();

    // user-gesture to start audio on click
    fg.addEventListener('click', ()=>{ if(!audioCtx && soundToggle.checked) initAudio(); if(audioCtx) audioCtx.resume(); if(!running){ running=true; startTime = performance.now(); requestAnimationFrame(render); } }, {once:false});

    // accessibility hint: tab focus
    document.addEventListener('keyup', (e)=>{ if(e.key === 'Tab') document.body.classList.add('show-focus'); });

    // ------------------------
    // Lightweight runtime "tests" (console.assert) so you get immediate feedback
    // about common environment issues (useful for debugging in different browsers)
    // ------------------------
    function runQuickChecks(){
      try{
        console.group('Perceptual Empathy — quick checks');
        const expectedLayers = Math.max(1, parseInt(complexityEl.value,10)||3);
        console.assert(Array.isArray(layers), 'layers should be an array');
        console.assert(layers.length === expectedLayers, `layers.length (${layers.length}) !== expected (${expectedLayers})`);
        console.assert(fbCanvas.width > 0 && fbCanvas.height > 0, 'feedback canvas has zero size');
        console.assert(copyCanvas.width > 0 && copyCanvas.height > 0, 'copy canvas has zero size');
        console.assert(typeof initAudio === 'function', 'initAudio should be a function');
        console.log('If any asserts failed above, paste them here and I will debug further.');
        console.groupEnd();
      }catch(e){ console.warn('Quick checks failed', e); }
    }
    setTimeout(runQuickChecks, 600);
  </script>
</body>
</html>
