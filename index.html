<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>RBXWatcher — Crypto Dashboard</title>
  <meta name="description" content="Track Roblox username availability (uses auth.roblox.com/v1/usernames/validate via a proxy)">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { background: radial-gradient(circle at top left, #071029 0%, #000 60%); color: #e6eef8; font-family: Inter, ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; }
    .glass { background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.04); }
    .ticker { animation: ticker 18s linear infinite; white-space: nowrap; }
    @keyframes ticker { 0% { transform: translateX(100%);} 100% { transform: translateX(-100%);} }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Segoe UI Mono', 'Noto Mono', monospace; }
  </style>
</head>
<body class="min-h-screen flex flex-col">
  <header class="w-full bg-black/70 border-b border-slate-800 p-4 flex items-center justify-between">
    <div class="flex items-center gap-3">
      <div class="rounded-full bg-emerald-400 w-8 h-8 flex items-center justify-center text-black font-bold">R</div>
      <div>
        <h1 class="text-lg font-semibold text-emerald-300">RBXWatcher</h1>
        <div class="text-xs text-slate-400">Crypto-styled username monitoring dashboard</div>
      </div>
    </div>
    <nav class="flex gap-6 text-slate-400 text-sm">
      <a href="#" class="hover:text-white">Dashboard</a>
      <a href="#" class="hover:text-white">Markets</a>
      <a href="#" class="hover:text-white">Docs</a>
    </nav>
  </header>

  <div class="overflow-hidden bg-slate-900 border-b border-slate-800 py-2">
    <div class="ticker text-emerald-400 text-sm flex gap-12 px-4">
      <span>GOLD • AVAILABLE ⚡</span>
      <span>NOOB • TAKEN ❌</span>
      <span>OFFICIAL • TAKEN ❌</span>
      <span>PRO • AVAILABLE ⚡</span>
    </div>
  </div>

  <main class="flex-grow flex items-start justify-center p-6">
    <section class="glass max-w-5xl w-full p-6 rounded-2xl shadow-lg">
      <div class="md:flex md:gap-6">
        <div class="md:flex-1">
          <label class="block text-xs text-slate-400">Watchlist (comma or newline separated)</label>
          <textarea id="usernames" rows="6" class="mt-2 w-full bg-black/50 border border-slate-700 rounded p-3 text-white mono" placeholder="RareName, OGTag, pro_player"></textarea>

          <div class="flex gap-3 mt-3">
            <button id="loadCommon" class="px-3 py-2 bg-indigo-600 hover:bg-indigo-700 rounded">Load common words</button>
            <button id="checkCommon" class="px-3 py-2 bg-emerald-500 hover:bg-emerald-600 rounded">Check common words</button>
            <button id="start" class="px-3 py-2 bg-emerald-500 hover:bg-emerald-600 rounded">Start</button>
            <button id="stop" class="px-3 py-2 bg-slate-600 hover:bg-slate-700 rounded">Stop</button>
            <button id="clear" class="px-3 py-2 bg-orange-500 hover:bg-orange-600 rounded">Clear</button>
          </div>

          <div class="mt-4 grid grid-cols-2 gap-3 text-sm text-slate-400">
            <div>
              <label class="block text-xs">Polling interval (ms)</label>
              <input id="interval" type="number" min="500" value="2000" class="mt-1 w-full bg-black/40 border border-slate-700 rounded p-2 text-white mono" />
            </div>
            <div>
              <label class="block text-xs">Worker / Proxy base URL</label>
              <input id="proxy" type="text" value="https://YOUR-PROXY.example" class="mt-1 w-full bg-black/40 border border-slate-700 rounded p-2 text-white mono" />
            </div>
          </div>

          <div class="mt-4 text-xs text-slate-400">
            This frontend calls the Roblox validate endpoint via a proxy worker you deploy (see comments at the bottom of the page). Use the proxy URL you get from Cloudflare Workers or any proxy that forwards requests to <code class="mono">https://auth.roblox.com</code> and returns CORS headers.
          </div>
        </div>

        <div class="md:w-96 mt-6 md:mt-0">
          <div class="flex items-center justify-between">
            <h3 class="text-lg font-semibold text-emerald-300">Order Book</h3>
            <div class="text-xs text-slate-400">Status: <span id="status">idle</span></div>
          </div>

          <div id="results" class="mt-3 max-h-[60vh] overflow-auto grid gap-2"></div>
        </div>
      </div>

      <div class="mt-6 text-xs text-slate-400">
        <strong>Notes:</strong> This UI uses <code class="mono">/v1/usernames/validate</code> with a birthday query param (2000-01-01 by default). Because Roblox's responses can vary (error arrays, numeric codes, etc.) the page shows the raw JSON for each check and applies a small heuristic to highlight "AVAILABLE" vs "TAKEN" when possible.
      </div>
    </section>
  </main>

  <footer class="bg-black/70 border-t border-slate-800 py-4 text-center text-xs text-slate-500">
    © 2025 RBXWatcher • Use responsibly • Respect Roblox TOS
  </footer>

  <script>
    // --- Config / Common words ---
    const commonWords = [
      'the','official','real','pro','x','admin','bot','dev','gamer','king','legend','best','play','game','owner','noob','123','hq','shop','server'
    ]

    // --- Helpers ---
    const $ = id => document.getElementById(id)
    const statusEl = $('status')
    const resultsEl = $('results')
    let intervalId = null

    function parseUsernames(raw) { return raw.split(/[
,]+/).map(s => s.trim()).filter(Boolean) }

    function saveState() {
      localStorage.setItem('rw_usernames', $('usernames').value)
      localStorage.setItem('rw_interval', $('interval').value)
      localStorage.setItem('rw_proxy', $('proxy').value)
    }
    function loadState() {
      $('usernames').value = localStorage.getItem('rw_usernames') || ''
      $('interval').value = localStorage.getItem('rw_interval') || '2000'
      $('proxy').value = localStorage.getItem('rw_proxy') || ''
    }
    loadState()

    function renderResult(name, statusLabel, raw) {
      const id = 'r_' + name.replace(/[^a-z0-9]/gi,'_')
      let el = document.getElementById(id)
      if (!el) {
        el = document.createElement('div')
        el.id = id
        el.className = 'p-3 rounded flex flex-col gap-1 border border-slate-700 bg-black/50'
        resultsEl.prepend(el)
      }
      const time = new Date().toLocaleTimeString()
      el.innerHTML = `
        <div class="flex items-center justify-between">
          <div><strong class="text-white">${name}</strong> <span class="text-slate-400 text-xs">${time}</span></div>
          <div>${statusLabel}</div>
        </div>
        <div class="text-xs text-slate-300 mono">${escapeHtml(JSON.stringify(raw))}</div>
      `
    }

    function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;') }

    // --- Check logic (uses validate endpoint via proxy) ---
    async function checkName(name, proxyBase) {
      const url = new URL(proxyBase)
      // append path for the worker, worker will forward path+query to auth.roblox.com
      url.pathname = '/v1/usernames/validate'
      url.searchParams.set('Username', name)
      url.searchParams.set('Birthday', '2000-01-01')

      const res = await fetch(url.toString(), { method: 'GET', headers: { 'Accept':'application/json' } })
      let data
      try { data = await res.json() } catch (e) { data = { raw: await res.text() } }

      // small heuristic:
      // - if data.code === 0 => treat as AVAILABLE
      // - if data.errors => show error
      // - otherwise, show raw and mark unknown
      if (data && typeof data.code === 'number') {
        if (data.code === 0) {
          renderResult(name, '<span class="text-emerald-400 font-bold">AVAILABLE ⚡</span>', data)
          notify(`${name} is available`)
          return
        } else {
          renderResult(name, '<span class="text-red-400 font-bold">TAKEN / INVALID ❌</span>', data)
          return
        }
      }

      if (Array.isArray(data && data.errors) && data.errors.length) {
        renderResult(name, '<span class="text-yellow-300">ERROR</span>', data)
        return
      }

      // fallback: try to interpret message
      const msg = (data && (data.message || data.userFacingMessage || '')) + ''
      if (/available/i.test(msg)) {
        renderResult(name, '<span class="text-emerald-400 font-bold">AVAILABLE ⚡</span>', data)
        notify(`${name} is available`)
      } else if (/taken|already|unavailable/i.test(msg)) {
        renderResult(name, '<span class="text-red-400 font-bold">TAKEN ❌</span>', data)
      } else {
        renderResult(name, '<span class="text-slate-400">UNKNOWN</span>', data)
      }
    }

    async function checkBatch(names, proxy) {
      if (!proxy) throw new Error('Proxy URL missing')
      // run serially to be gentler on Roblox (and avoid worker rate limits)
      for (const n of names) {
        try { await checkName(n, proxy) } catch (e) { renderResult(n, '<span class="text-yellow-300">ERR</span>', { error: e.message }) }
      }
    }

    function notify(msg) {
      if (Notification.permission === 'granted') new Notification(msg)
      else if (Notification.permission !== 'denied') Notification.requestPermission().then(p => { if (p === 'granted') new Notification(msg) })
    }

    // --- Controls ---
    $('start').addEventListener('click', () => {
      const names = parseUsernames($('usernames').value)
      if (!names.length) return alert('Add at least one username')
      const interval = Math.max(500, parseInt($('interval').value, 10) || 2000)
      const proxy = $('proxy').value.trim()
      if (!proxy) return alert('Set proxy base URL')

      saveState()
      if (intervalId) clearInterval(intervalId)
      statusEl.textContent = `running — ${names.length} names / ${interval}ms`

      (async () => { try { await checkBatch(names, proxy) } catch (e) { alert(e.message) } })()
      intervalId = setInterval(() => { checkBatch(names, proxy).catch(console.error) }, interval)
    })

    $('stop').addEventListener('click', () => { if (intervalId) { clearInterval(intervalId); intervalId = null } statusEl.textContent = 'idle' })
    $('clear').addEventListener('click', () => { $('usernames').value = ''; resultsEl.innerHTML = '' })

    $('loadCommon').addEventListener('click', () => { $('usernames').value = commonWords.join(', '); saveState() })
    $('checkCommon').addEventListener('click', async () => {
      const proxy = $('proxy').value.trim(); if (!proxy) return alert('Set proxy base URL')
      statusEl.textContent = 'checking common words...'
      await checkBatch(commonWords, proxy)
      statusEl.textContent = 'idle'
    })

    // hotkeys
    document.addEventListener('keydown', e => { if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) $('start').click() })

  </script>

  <!-- Worker example: deploy this to Cloudflare Workers (paste and deploy), then put the Worker URL into the Proxy field above.
       The worker simply forwards the incoming request's path+query to auth.roblox.com and mirrors the response with CORS headers.

addEventListener('fetch', event => { event.respondWith(handle(event.request)) })

async function handle(req) {
  // quick CORS for preflight
  const corsHeaders = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET,POST,OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type'
  }
  if (req.method === 'OPTIONS') return new Response(null, { status: 204, headers: corsHeaders })

  const incoming = new URL(req.url)
  // forward the pathname + search to auth.roblox.com
  const target = 'https://auth.roblox.com' + incoming.pathname + incoming.search

  const init = {
    method: req.method,
    headers: { 'User-Agent': 'RBXWatcher/1.0' },
    body: ['GET','HEAD'].includes(req.method) ? undefined : await req.text()
  }

  const resp = await fetch(target, init)
  const body = await resp.text()
  const headers = new Headers(resp.headers)
  headers.set('Access-Control-Allow-Origin', '*')
  headers.set('Access-Control-Allow-Methods', 'GET,POST,OPTIONS')
  headers.set('Access-Control-Allow-Headers', 'Content-Type')

  return new Response(body, { status: resp.status, headers })
}

  -->
</body>
</html>
