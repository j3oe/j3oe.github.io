<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Minecraft Name Watcher — TradingView style</title>

  <!-- Chart.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

  <style>
    :root{
      --bg:#0f1724; --card:#0b1220; --accent:#00c2ff; --muted:#94a3b8; --glass: rgba(255,255,255,0.03);
      --success:#22c55e; --danger:#ef4444;
    }
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;}
    body{background:linear-gradient(180deg,#071027 0%,#081426 100%); color:#e6eef8; padding:18px;}
    .container{max-width:1100px;margin:0 auto;}
    header{display:flex;align-items:center;gap:16px;margin-bottom:18px;}
    h1{font-size:20px;margin:0}
    .card{background:var(--card); border-radius:12px; padding:14px; box-shadow:0 6px 22px rgba(2,6,23,0.6); margin-bottom:12px;}
    .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center;}
    input[type="text"]{padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:var(--glass);color:inherit}
    button{padding:10px 12px;border-radius:8px;border:none;background:var(--accent);color:#001;cursor:pointer}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
    .list{margin-top:12px;display:flex;gap:8px;flex-wrap:wrap}
    .tag{background:rgba(255,255,255,0.02);padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.02)}
    .row{display:flex;gap:8px;align-items:center;justify-content:space-between}
    #status{font-size:13px;color:var(--muted);margin-top:8px}
    .log{height:160px;overflow:auto;padding:10px;border-radius:8px;background:rgba(0,0,0,0.15);margin-top:12px;font-family:monospace;font-size:13px}
    .small{font-size:13px;color:var(--muted)}
    .name-row{display:flex;gap:8px;align-items:center}
    .name-item{display:flex;gap:12px;align-items:center;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.02);min-width:220px}
    .available{color:var(--success);font-weight:600}
    .taken{color:var(--danger);font-weight:600}
    footer{margin-top:14px;color:var(--muted);font-size:13px}
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Minecraft Name Watcher — TradingView style</h1>
      <div class="small">Polite watcher using Mojang public API • Respects rate limits</div>
    </header>

    <div class="card">
      <div class="controls">
        <input id="nameInput" type="text" placeholder="Add username to watch (a-z, 3-16 chars)" />
        <button id="addBtn">+ Add</button>
        <label class="small">Poll interval (s):
          <input id="intervalInput" type="number" value="15" min="5" style="width:70px;margin-left:8px;padding:6px;border-radius:6px;border:none"/>
        </label>
        <button id="startBtn">Start</button>
        <button id="stopBtn" class="ghost" disabled>Stop</button>
        <button id="clearLog" class="ghost">Clear Log</button>
      </div>

      <div id="watchList" class="list" aria-live="polite" style="margin-top:12px"></div>
      <div id="status" class="small">Idle</div>
    </div>

    <div class="card">
      <canvas id="chart" height="120"></canvas>
      <div class="small" style="margin-top:8px">Chart: checks per minute & availability events</div>
    </div>

    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div><strong>Activity log</strong></div>
        <div class="small">Notifications must be allowed in browser</div>
      </div>
      <div id="log" class="log"></div>
    </div>

    <footer>
      Uses Mojang public endpoints — do not abuse. For educational purposes only. See Mojang API docs / wiki.vg for details.
    </footer>
  </div>

<script>
/*
  Polite name watcher:
  - Uses Mojang username endpoint: GET https://api.mojang.com/users/profiles/minecraft/{name}
    (200 => taken, 204/404 => available / not found historically)
  - Exponential backoff on 429 or network error.
  - Chart shows checks/min and events.
  - Respect the API: default interval 15s, minimum 5s. Do NOT use for automated sniping.
*/

const API_BASE = 'https://api.mojang.com/users/profiles/minecraft';
const minIntervalSec = 5;

let watchNames = []; // {name, status}
let timer = null;
let intervalSec = 15;
let backoffMultiplier = 1;
let checksThisMinute = 0;
let chartData = { labels: [], checks: [], events: [] };
let chart = null;

const el = {
  nameInput: document.getElementById('nameInput'),
  addBtn: document.getElementById('addBtn'),
  startBtn: document.getElementById('startBtn'),
  stopBtn: document.getElementById('stopBtn'),
  intervalInput: document.getElementById('intervalInput'),
  watchList: document.getElementById('watchList'),
  status: document.getElementById('status'),
  log: document.getElementById('log'),
  clearLog: document.getElementById('clearLog')
};

function log(msg){
  const t = new Date().toLocaleTimeString();
  el.log.innerText = `[${t}] ${msg}\n` + el.log.innerText;
}
function renderList(){
  el.watchList.innerHTML = '';
  watchNames.forEach(w=>{
    const div = document.createElement('div');
    div.className = 'name-item';
    div.innerHTML = `<div style="min-width:120px"><strong>${w.name}</strong></div>
                     <div class="${w.status==='available'?'available':'taken'}">${w.status||'unknown'}</div>
                     <div style="margin-left:auto"><button data-name="${w.name}" class="rm">Remove</button></div>`;
    el.watchList.appendChild(div);
  });
  Array.from(document.getElementsByClassName('rm')).forEach(b=>{
    b.onclick = e=>{
      const n = e.target.getAttribute('data-name');
      watchNames = watchNames.filter(x=>x.name!==n);
      renderList();
    };
  });
}

function addName(n){
  n = n.trim();
  if(!/^[a-z0-9_]{3,16}$/.test(n)){
    alert('Invalid Minecraft username format (lowercase letters, numbers, underscore, 3-16 chars).');
    return;
  }
  if(watchNames.some(w=>w.name===n)) return;
  watchNames.push({name:n, status:'unknown'});
  renderList();
  log('Added ' + n);
}

el.addBtn.onclick = ()=>{ addName(el.nameInput.value); el.nameInput.value=''; }
el.intervalInput.onchange = ()=> {
  const v = parseInt(el.intervalInput.value||'15',10);
  intervalSec = Math.max(minIntervalSec, v);
  log('Interval set to ' + intervalSec + 's (please be polite)');
}

el.clearLog.onclick = ()=> { el.log.innerText = ''; }

el.startBtn.onclick = ()=>{
  if(watchNames.length===0){ alert('Add at least one name'); return; }
  intervalSec = Math.max(minIntervalSec, parseInt(el.intervalInput.value||'15',10));
  startWatching();
};
el.stopBtn.onclick = stopWatching;

function startWatching(){
  if(timer) return;
  el.startBtn.disabled = true;
  el.stopBtn.disabled = false;
  el.status.innerText = 'Running — polling every ' + intervalSec + 's';
  // reset counters
  checksThisMinute = 0;
  chartData = { labels:[], checks:[], events:[] };
  initChart();
  // minute bucket for checks per min
  setInterval(()=> {
    chartPushBucket(checksThisMinute);
    checksThisMinute = 0;
  }, 60*1000);
  scheduleNextCheck(0);
}

function stopWatching(){
  if(timer){ clearTimeout(timer); timer = null; }
  el.startBtn.disabled = false;
  el.stopBtn.disabled = true;
  el.status.innerText = 'Stopped';
  log('Watcher stopped');
}

// schedule with current backoff multiplier
function scheduleNextCheck(delaySec){
  const s = Math.max(0,delaySec) * 1000;
  timer = setTimeout(()=> runChecks(), s);
}

async function runChecks(){
  if(watchNames.length===0){ stopWatching(); return; }
  el.status.innerText = `Running — checking ${watchNames.length} name(s) (backoff x${backoffMultiplier})`;
  for(const entry of watchNames){
    try{
      await checkSingle(entry);
      // gentle delay between names to avoid burst
      await sleep(200 + Math.random()*300);
    } catch(err){
      console.error('check error', err);
      log('Network error checking ' + entry.name + ' — ' + (err.message||err));
      // if network error, we'll increase backoff below
    }
  }
  // update minute counter
  checksThisMinute += watchNames.length;
  // reset multiplier on success (keep small backoff)
  backoffMultiplier = Math.max(1, backoffMultiplier * 0.9);
  // schedule next
  const nextSec = intervalSec * backoffMultiplier;
  scheduleNextCheck(nextSec);
}

async function checkSingle(entry){
  // Use Mojang public endpoint
  const url = `${API_BASE}/${encodeURIComponent(entry.name)}`;
  // The simple lookup returns 200 if the name exists, 204/404 if not — handle statuses safely
  let resp;
  try{
    resp = await fetch(url, { method:'GET', cache: 'no-store' });
  } catch(e){
    // network error => increase backoff
    backoffMultiplier = Math.min(60, backoffMultiplier*1.8);
    throw e;
  }

  if(resp.status === 200){
    // name taken
    if(entry.status !== 'taken'){
      entry.status = 'taken';
      log(`${entry.name} — taken`);
      chartAddEvent(entry.name, 'taken');
    }
  } else if(resp.status === 204 || resp.status === 404){
    // likely available
    if(entry.status !== 'available'){
      entry.status = 'available';
      log(`${entry.name} — AVAILABLE!`);
      chartAddEvent(entry.name, 'available');
      notify(`${entry.name} is available!`);
    }
  } else if(resp.status === 429){
    log('Rate limited (429). Increasing backoff.');
    backoffMultiplier = Math.min(60, backoffMultiplier*1.4);
    // leave entry status unchanged
  } else {
    // other statuses — handle gracefully
    const text = await resp.text().catch(()=> '');
    log(`Unexpected response for ${entry.name}: ${resp.status} ${text.slice(0,80)}`);
  }
  renderList();
}

function notify(msg){
  if(Notification.permission === 'granted'){
    new Notification('Name Watcher', { body: msg });
  } else if(Notification.permission !== 'denied'){
    Notification.requestPermission().then(p => {
      if(p === 'granted') new Notification('Name Watcher', { body: msg });
    });
  }
}

/* chart helpers */
function initChart(){
  const ctx = document.getElementById('chart').getContext('2d');
  if(chart) chart.destroy();
  chart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: chartData.labels,
      datasets: [
        { label: 'Checks / min', data: chartData.checks, yAxisID: 'y' },
        { label: 'Availability events', data: chartData.events, type: 'line', yAxisID: 'y2', tension:0.3, pointRadius:6 }
      ]
    },
    options: {
      responsive:true,
      scales: {
        y: { position:'left', beginAtZero:true },
        y2: { position:'right', beginAtZero:true, grid: { display:false } }
      },
      plugins: { legend: { position:'top' } }
    }
  });
}

function chartPushBucket(count){
  const label = new Date().toLocaleTimeString();
  chartData.labels.push(label);
  chartData.checks.push(count);
  chartData.events.push(null);
  if(chartData.labels.length > 30){
    chartData.labels.shift();
    chartData.checks.shift();
    chartData.events.shift();
  }
  updateChart();
}

function chartAddEvent(name, type){
  // put a marker on the last bucket (or create one)
  const idx = chartData.labels.length ? chartData.labels.length - 1 : 0;
  const val = type === 'available' ? 1 : 0.5;
  // ensure arrays are consistent
  while(chartData.labels.length <= idx){
    chartData.labels.push(new Date().toLocaleTimeString());
    chartData.checks.push(0);
    chartData.events.push(null);
  }
  chartData.events[idx] = val;
  updateChart();
}

function updateChart(){
  if(!chart) initChart();
  chart.data.labels = chartData.labels;
  chart.data.datasets[0].data = chartData.checks;
  chart.data.datasets[1].data = chartData.events;
  chart.update();
}

function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

// Initialize
renderList();
initChart();
log('Ready. Add names and click Start. Remember: be polite to Mojang/NameMC and do not attempt to bypass protections.');
</script>
</body>
</html>
